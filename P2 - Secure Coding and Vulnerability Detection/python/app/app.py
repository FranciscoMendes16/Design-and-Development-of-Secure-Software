#!/usr/bin/env python
# -*- coding: utf-8 -*-

from flask import Flask, render_template, request, redirect, url_for, session, flash
import logging, psycopg2, bcrypt

import os

app = Flask(__name__)

app.secret_key = os.urandom(24)

StatusCodes = {
    'success': 200,
    'api_error': 400,
    'internal_error': 500
}


def authenticate_user(connection, username, user_password):
    cursor = connection.cursor()

    try:
        cursor.execute('SELECT password FROM users WHERE username = %s', (username,))
        retrieved_password_hash = cursor.fetchone()
        if retrieved_password_hash:
            # Checking password validity using bcrypt
            logger.info("fail")
            if bcrypt.checkpw(user_password.encode('utf-8'), retrieved_password_hash[0].encode('utf-8')):
                logger.info("success")
                return True
            else:
                logger.info("fail")
                return False
            
    except (Exception, psycopg2.DatabaseError) as db_error:
        logging.error(f'Authentication error: {db_error}')
        return False
    
    finally:
        if cursor:
            cursor.close()





@app.route("/")
def home():
    return render_template("index.html")


@app.route("/part1.html", methods=['GET'])
def login():
    if "user" in session:
        return redirect(url_for('part2'))
    return render_template("part1.html")


@app.route("/logout")
def logout():
    if "user" in session:
        session.pop("user", None)
        logger.info("Logout successful!")
    return redirect(url_for("login"))


@app.route("/registration1.html", methods=['GET', 'POST'])
def register():
    return render_template("registration1.html")





@app.route("/register_user", methods=['GET', 'POST'])
def register_user():
    logger.info("---- User Registration ----")

    if request.method == 'GET':
        password = request.args.get('password')
        username = request.args.get('username')
        password_confirmation = request.args.get('confirm_password')

    else:
        password = request.form['password']
        username = request.form['username']
        password_confirmation = request.form['confirm_password']
    
    logger.info('Attempting to register a new user')

    logger.info("Username -> " + username)
    # Hashing the password and password confirmation using bcrypt
    pw_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    password_confirmation_hash = bcrypt.hashpw(password_confirmation.encode('utf-8'), bcrypt.gensalt())
    password_hash = pw_hash.decode('utf-8')

    # Logging the hashed passwords (consider the security implications)
    logger.info("Hashed Password -> " + password_hash)
    logger.info("Hashed Confirmation Password -> " + password_confirmation_hash.decode('utf-8'))

    # Establishing database connection
    connection = get_db()
    cursor = connection.cursor()
    
    try:
        cursor.execute('SELECT username FROM users WHERE username = %s', (username,))
        existing_username = cursor.fetchone()
        # Check if the username already exists
        if existing_username is None:
            if password == password_confirmation:
                # Using parameterized queries for security
                insert_query = 'INSERT INTO users (username, password) VALUES (%s, %s)'
                insert_values = (username, password_hash)
                cursor.execute(insert_query, insert_values)
                # Committing the transaction
                connection.commit()

                return redirect(url_for("login"))
            
            else:
                flash("Passwords do not match!", "registration_error")
                return render_template("registration1.html")
            
        else:
            flash("Username already in use!", "registration_error")
            return render_template("registration1.html")
        
    except (Exception, psycopg2.DatabaseError) as db_error:
        # Handle any database errors
        connection.rollback()
        logger.error(f'Registration error: {db_error}')

    finally:
        if connection is not None:
            connection.close()

    return render_template("registration1.html")




@app.route("/register_user_vuln", methods=['GET', 'POST'])
def register_user_vuln():
    logger.info("---- User Registration ----")

    if request.method == 'GET':
        v_password = request.args.get('v_password')
        v_username = request.args.get('v_username')
        v_password_confirmation = request.args.get('v_confirm_password')
    else:
        v_password = request.form['v_password']
        v_username = request.form['v_username']
        v_password_confirmation = request.form['v_confirm_password']

    logger.info('Attempt to register a vulnerable user')

    logger.info("Username -> " + v_username)
    logger.info("Password -> " + v_password)
    logger.info("Confirm Password -> " + v_password_confirmation)

    # Establishing database connection
    connection = get_db()
    cursor = connection.cursor()
    
    try:
        v_query = f"SELECT username FROM users_vulnerable WHERE username = '{v_username}'"  
        cursor.execute(v_query)
        existing_v_username = cursor.fetchone()

        if existing_v_username is None:
            if v_password == v_password_confirmation:
                insert_query = f"INSERT INTO users_vulnerable (username, password) VALUES ('{v_username}', '{v_password}')"  
                cursor.execute(insert_query)
                connection.commit()

                return redirect(url_for("login"))
            
            else:
                flash("Passwords must match!", "registration2_error")
                return render_template("registration1.html") 
                   
        else:
            flash("Username already exists!", "registration2_error")
            return render_template("registration1.html")

    except (Exception, psycopg2.DatabaseError) as db_error:
        connection.rollback()
        logger.error(f'Registration error: {db_error}')

    finally:
        if connection is not None:
            connection.close()

    return render_template("registration1.html")




@app.route("/part1_vulnerable", methods=['GET', 'POST'])
def part1_vulnerable():
    logger.info("---- part1_vulnerable ----")

    if request.method == 'GET':
        v_password = request.args.get('v_password') 
        v_username = request.args.get('v_username') 
        v_remember = request.args.get('v_remember') 

    else:
        v_password = request.form['v_password']
        v_username = request.form['v_username']
        v_remember = request.form['v_remember']
        

    logger.info("Vulnerable Username -> " + v_username)
    logger.info("Vulnerable Password -> " + v_password)

    # Establishing database connection
    connection = get_db()
    cursor = connection.cursor()

    try:
        # Intentionally vulnerable SQL query
        vulnerable_query = f"SELECT password FROM users_vulnerable WHERE username = '{v_username}'"
        cursor.execute(vulnerable_query)
        retrieved_password = cursor.fetchone()

        if retrieved_password is None:
            flash("User does not exist!", "registration2_error")
            return redirect(url_for('login'))
        
        else:
            if v_password == retrieved_password[0]:
                session["user"] = v_username

                # Setting session persistence based on user choice
                session.permanent = True if v_remember == "on" else False

                logger.info("Login successful!")
                return redirect(url_for("part2"))
            else:
                flash("Incorrect password!", "registration2_error")
                return redirect(url_for('login'))

    except (Exception, psycopg2.DatabaseError) as db_error:
        connection.rollback()
        logger.error(f'Error in vulnerable login: {db_error}')

    finally:
        if connection is not None:
            connection.close()

    return redirect(url_for('login'))





@app.route("/part1_correct", methods=['GET', 'POST'])
def part1_correct():
    logger.info("---- part1_correct ----")

    if request.method == 'GET':
        password = request.args.get('password') 
        username = request.args.get('username') 
        remember = request.args.get('remember')
        
    else:
        password = request.form['password']
        username = request.form['username']
        remember = request.form.get('remember')
        
    
        
    logger.info("Username  -> " + username)
    hashed_password_for_logging = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    logger.info("Password -> " + hashed_password_for_logging)
    

    #Connection to db
    connection = get_db()
    cursor = connection.cursor()
    
    try:
        cursor.execute('SELECT username FROM users WHERE username = %s', (username,))
        existing_username = cursor.fetchone()

        #Check if it exists the input username
        if existing_username == None:
            flash("Credentials Wrong!","registration_error")
            return redirect(url_for('login'))
        
        else:
            logger.info("still here")
            if (authenticate_user(connection, username, password)):
                
                session["user"] = username

                session.permanent = True if remember == "on" else False

                logger.info("Authentication Successful!")
                return redirect(url_for("part2"))
                
            else:
                flash("Incorrect username or password!","registration_error")
                return redirect(url_for('login'))

    except (Exception, psycopg2.DatabaseError) as db_error:
        connection.rollback()
        logger.error(f'Login error: {db_error}')

    finally:
        if connection is not None:
            connection.close()

    return redirect(url_for('login'))





@app.route("/part2.html", methods=['GET'])
def part2():

    if "user" in session:
        logger.info('Fetching Messages from Dashboard')

        connection = get_db()
        cursor = connection.cursor()

        try:
            cursor.execute('SELECT author, message FROM messages')
            message_records = cursor.fetchall()

            logger.debug('Parsing Messages for Dashboard')
            dashboard_messages = []

            for record in message_records:
                logger.debug(record)
                info = {'author': record[0], 'message': record[1]}
                dashboard_messages.append(info) 


        except (Exception, psycopg2.DatabaseError) as db_error:
            logger.error(f'Error Fetching Messages: {db_error}')

        finally:
            if connection is not None:
                connection.close()

        return render_template("part2.html", messages=dashboard_messages)
    else:
        return redirect(url_for("login"))




@app.route("/part2_vulnerable", methods=['GET', 'POST'])
def part2_vulnerable():

    if "user" in session:
        logger.info("---- part2_vulnerable ----")

        if request.method == 'GET':
            v_text = request.args.get('v_text') 
        else:
            v_text = request.form['v_text']
        
        logger.info("Attempting to post a message")
        logger.info("Vulnerable Text -> " + v_text)

        #Connection to db
        connection = get_db()
        cursor = connection.cursor()
        
        v_username = session["user"]
                                                               

        try:
            v_query = f"INSERT INTO messages (author, message) VALUES ('{v_username}', '{v_text}')"
            cursor.execute(v_query)
            
            connection.commit()
            return redirect(url_for('part2'))

        except (Exception, psycopg2.DatabaseError) as db_error:
            
            connection.rollback()
            logger.error(f'Error in posting message: {db_error}')

        finally:
            if connection is not None:
                connection.close()    

        return render_template("part2.html")
    else:
        return redirect(url_for("login"))





@app.route("/part2_correct", methods=['GET', 'POST'])
def part2_correct():

    if "user" in session:
        logger.info("---- part2_correct ----")

        if request.method == 'GET':
            text = request.args.get('text') 
        else:
            text = request.form['text']
        
        logger.info("Attempting to post a message")
        logger.info("Text  -> " + text)

        #Connection to db
        connection = get_db()
        cursor = connection.cursor()
        
        username = session["user"]

        try:
            query = 'INSERT INTO messages (author, message) VALUES (%s, %s)'
            values = (username, text)
            cursor.execute(query, values)
            connection.commit()
            return redirect(url_for('part2'))

        except (Exception, psycopg2.DatabaseError) as db_error:
           
            connection.rollback()
            logger.error(f'Error in posting secure message: {db_error}')

        finally:
            if connection is not None:
                connection.close()    

        return render_template("part2.html")
    
    else:
        return redirect(url_for("login"))






@app.route("/part3.html", methods=['GET'])
def part3():

    return render_template("part3.html")

@app.route("/part3_vulnerable", methods=['GET', 'POST'])
def part3_vulnerable():
    
   

    return "/part3_vulnerable"


@app.route("/part3_correct", methods=['GET', 'POST'])
def part3_correct():
    

    return "/part3_correct"


@app.route("/demo", methods=['GET', 'POST'])
def demo():
    logger.info(" DEMO \n");   

    conn = get_db()
    cur = conn.cursor()

    logger.info("---- users  ----")
    cur.execute("SELECT * FROM users")
    rows = cur.fetchall()

    for row in rows:
        logger.info(row)


    logger.info("---- users_vulnerable ----")
    cur.execute("SELECT * FROM users_vulnerable")
    rows = cur.fetchall()

    for row in rows:
        logger.info(row)

    logger.info("---- messages ----")
    cur.execute("SELECT * FROM messages")
    rows = cur.fetchall()
 
    for row in rows:
        logger.info(row)

    logger.info("---- books ----")
    cur.execute("SELECT * FROM books")
    rows = cur.fetchall()
 
    for row in rows:
        logger.info(row)

    conn.close ()
    logger.info("\n---------------------\n\n") 

    return "/demo"


##########################################################
## DATABASE ACCESS
##########################################################

def get_db():
    db = psycopg2.connect(user = "ddss-database-assignment-2",
                password = "ddss-database-assignment-2",
                host = "db",
                port = "5432",
                database = "ddss-database-assignment-2")
    return db



##########################################################
## MAIN
##########################################################
if __name__ == "__main__":
    logging.basicConfig(filename="log_file.log")

    logger = logging.getLogger('logger')
    logger.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)

    # create formatter
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(name)s:  %(message)s')

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    logger.addHandler(ch)

    logger.info("\n---------------------\n\n")

    app.run(host="0.0.0.0", debug=True, threaded=True)





